from argparse import ArgumentParser 
import sys 
import random



class Player:
    """Creates an abstract class called Player for a player
    
    Attributes: 
    name(str): the player's name
    """
def __init__(self, name):
    self.name = name

def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the coordinates that the player guessed
            """
        raise NotImplementedError("Subclasses implement the 'turn' method")

class HumanPlayer(Player):
    """Class for human player
    
    Attributes:
    name(str): the player's name"""
    def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the player's guess (a letter or a word)
            """
        
        print(f"{self.name}, guess a set of coordinates of a hidden object: {state}")
        return input()

class ComputerPlayer(Player):
    """ Class for a computer player
    
    Attributes: 
        name(str): the player's name
        vocab(list of strings): words that the computer can draw from when taking turns
        """
    def __init__(self, name, grid):
      super().__init__(name)
      self.grid = grid



#play function
def play(self):
        """Play the game.
        
        Side effects:
            Writes to stdout.
            See also turn().
        """

        while self.outcome() is None:
            turn += 1
            player = self.players[turn % len(self.players)]
            if self.score[player.name] < self.objects:
                continue
            self.turn(player)
        print(self.state().board)
        outcome = self.outcome()
        if outcome == "win":
            print(f"{player.name} wins!")
        else:
            print(f"The {object} was buried at {coordinates}. Play again 
                  for another chance to find treasure!")
            

#Remy's Methods

def outcome(Player):
    """Determines if there is a winner or loser

    Args:
        Player (Player): A player object that will play the game

    Returns:
        str: outcome of the game (i.e. player one wins/loses or None if the 
        the game is not over)
    """
    
    if Player.objects.contains("Treasure"):
        return "win"
    elif Player.objects.contains("Bomb"):
        return "lose"
    else:
        return None
    
#Aileen's methods for set operations and comprehension **changed technique** 
def guess(players_guess):
    guessed_coords = set()
    unguessed_coords = set()
    coordinates = {"A1", "B1" "C1", "D1", "E1",
                "A2", "B2", "C2", "D2", "E2",
                "A3", "B3", "C3", "D3", "E3",
                "A4", "B4", "C4", "D4", "E4",
                "A5", "B5", "C5", "D5", "E5"}
    guessed_coords.add(players_guess)
    unguessed_coords = {coordinates - guessed_coords}
    print(guessed_coords)
    print(unguessed_coords)

def wrong_guesses(guessed_coords, item_locations):
    wrong_coords = {coord for coord in guessed_coords if coord not in 
                        item_locations}
    print(wrong_coords)

def place_item():
    item_location = {}
    item_location["treasure chest"] = input('''Where do you want to place the 
                                            treasure chest?''')
    item_location["broken bottle"] = input('''Where do you want to place the 
                                            broken bottle?''')
    item_location["shovel"] = input('''Where do you want to place the shovel?''')
    item_location["bomb"] = input('''Where do you want to place the bomb?''')
    
    return (item_location)
    
    
def main(HumanPlayer, GameBoard, ComputerPlayer=None):
    print("Welcome to Treasure Hunt!")
    name1 = input("To get started, please enter your name: ")
    human1=HumanPlayer(name1)
    players = input("How many players are playing today?(1 or 2) ")
    
    while players > 2 or players < 1:
        players = input("Please ONLY enter 1 or 2 players: ")
        
    if players == 1:
        ComputerPlayer = ComputerPlayer("Rob-ot")
    elif players == 2:
        name2 = input("Please enter the second player's name: ")
        human2 = HumanPlayer(name2)
            

    difficulty = input("Would you like to play on easy or hard mode? ")
    while not(difficulty == "easy" or difficulty == "hard"):
        difficulty = input("Please ONLY enter 'easy' or 'hard': ")
   
    game=GameBoard(difficulty)
    
    
    if ComputerPlayer == None:
        human2=HumanPlayer
        while outcome(human1) is None and outcome(human2) is None:
            play(human1)
            play(human2)
            print(game)
    elif ComputerPlayer is not None:
        while outcome(ComputerPlayer) is None and outcome(human1) is None:
                play(human1)
                play(ComputerPlayer)
                print(game)



#Adom's methods
def item_hit(self,item):
    "You hit a shovel, you get one more turn" if item == "shovel" else "You hit\
    hit a broken bottle, skip your turn" if item == "broken bottle" else "You\
    hit a bomb, you lose" if item == "bomb" else "You found the chest,\
    you win!" if item == "chest" else "You didn't find anything" 

def place_item_comp(self):
    if self.board == easy_mode:
        #list of items to place on board
        items = ["shovel","broken bottle", "bomb","chest"]
        #create a list for the computer to keep track of where items are placed
        letter_choice = 'ABCDE'
        comp_items = []
        while items in items != len(0):
            items.pop()
            # make a random choice for the column
            comp_column = random.choice(letter_choice)
            #make a random choice for the row 
            comp_row = random.randint(1,5)
            #append the choice to the comp_items list as a tuple to keep track
            comp_items.append(tuple(comp_column,comp_row))
        return comp_items
    else:
        let_hard = "ABCDEFGHIJ"
        comp_items_hard =[]
        while items in items != len(0): 
            items.pop()
            comp_column = random.choice(let_hard)
            comp_row = random.randint(1,10)
            comp_items_hard.append(tuple(comp_column,comp_row))
        return comp_items_hard 
    
def parse_args(arglist):
    """ Parse command-line arguments
    
    Expect mandatory arguments:
        - p1: name of player 1
        
    Allow optional second player is applicable:
        - p2, --player2: if specified, include a second player 
    """
    parser = ArgumentParser()
    parser.add_argument("p1", help="name of player 1")
    parser.add_argument("p2", "--player2", help="add a second player")
    
    return parser.parse_args(arglist)

if __name__ == "__main__":
    args = parse_args(sys.argv[1:])
    main(args.p1, args.player2)




Deandre's methods

import random

class GameBoard:
    def __init__(self, difficulty="easy"):
        """
        Initialize the game board with the specified difficulty.

        Args:
        difficulty (str): Either "easy" (default) or "hard" to determine the grid size.
        """
        self.difficulty = difficulty
        self.grid_size = 8 if difficulty == "easy" else 10
        self.grid = [[' ' for _ in range(self.grid_size)] for _ in range(self.grid_size)]
        self.items = [(random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1)) for _ in range(self.grid_size)]

    def grid_state(self, guess):
        """
        Update the game board based on the player's guess.

        Args:
        guess (tuple): A tuple containing the player's guess as (row, column).

        Returns:
        str: A string representing the game board's current state.
        """
        row, col = guess

        if guess in self.items:
            self.items.remove(guess)
            self.grid[row][col] = 'X'  # Mark the item as found
        else:
            self.grid[row][col] = 'O'  # Mark the guess as a miss

    def __str__(self):
        """
        Provide a string representation of the game board's current state.

        Returns:
        str: A string representing the game board.
        """
        game_state = ""
        for i in range(self.grid_size):
            for j in range(self.grid_size):
                if (i, j) in self.items:
                    game_state += ' '
                else:
                    game_state += self.grid[i][j]
                game_state += ' '
            game_state += '\n'

        return game_state


difficulty = "hard"  
game = GameBoard(difficulty)

print(game)  
game.grid_state((1, 2))  
print(game)  

