
#Kirstin's methods


class Player:
    """Creates an abstract class called Player for a player
    
    Attributes: 
    name(str): the player's name
    """
def __init__(self, name):
    self.name = name

def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the coordinates that the player guessed
            """
        raise NotImplementedError("Subclasses implement the 'turn' method")

class HumanPlayer(Player):
    """Class for human player
    
    Attributes:
    name(str): the player's name"""
    def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the player's guess (a letter or a word)
            """
        
        print(f"{self.name}, guess a set of coordinates of a hidden object: {state}")
        return input()

class ComputerPlayer(Player):
    """ Class for a computer player
    
    Attributes: 
        name(str): the player's name
        vocab(list of strings): words that the computer can draw from when taking turns
        """
    def __init__(self, name, grid):
      super().__init__(name)
      self.grid = grid



#play function
def play(self):
        """Play the game.
        
        Side effects:
            Writes to stdout.
            See also turn().
        """

        while self.outcome() is None:
            turn += 1
            player = self.players[turn % len(self.players)]
            if self.score[player.name] < self.objects:
                continue
            self.turn(player)
        print(self.state().board)
        outcome = self.outcome()
        if outcome == "win":
            print(f"{player.name} wins!")
        else:
            print(f"The {object} was buried at {coordinates}. Play again 
                  for another chance to find treasure!")
            

#Remy's Methods

def outcome(Player):
    if Player.objects.contains("Treasure"):
        return f"We have a winner! {Player} found the treasure!"
    elif Player.objects.contains("Bomb"):
        return f"Oh no, {Player} found the bomb. You lose!"
    else:
        return None
    
#Aileen's methods for set operations and comprehension **changed technique** 
def guess(players_guess):
    guessed_coords = set()
    unguessed_coords = set()
    coordinates = {"A1", "B1" "C1", "D1", "E1",
                "A2", "B2", "C2", "D2", "E2",
                "A3", "B3", "C3", "D3", "E3",
                "A4", "B4", "C4", "D4", "E4",
                "A5", "B5", "C5", "D5", "E5"}
    guessed_coords.add(players_guess)
    unguessed_coords = {coordinates - guessed_coords}
    print(guessed_coords)
    print(unguessed_coords)

def wrong_guesses(guessed_coords, item_locations):
    wrong_coords = {coord for coord in guessed_coords if coord not in 
                        item_locations}
    print(wrong_coords)

def place_item():
    item_location = {}
    item_location["treasure chest"] = input('''Where do you want to place the 
                                            treasure chest?''')
    item_location["broken bottle"] = input('''Where do you want to place the 
                                            broken bottle?''')
    item_location["shovel"] = input('''Where do you want to place the shovel?''')
    item_location["bomb"] = input('''Where do you want to place the bomb?''')
    
    return (item_location)
