from argparse import ArgumentParser 
import sys 
import random



class Player:
    """
    Represents a player in the Treasure Hunt game.
    
    Attributes: 
    - name(str): the name of the player.
    - item(str): the item to be placed.
    - row(str): the row where the item is placed (letter A-J).
    - col(int): the column where the item is placed (1-10).
    
    """

    def __init__(self, name):
        """
        Initializes a new Player instance.

        Args:
        - name (str): The name of the player.
        """
        self.name = name
        self.items = {item: None for item in ['Treasure Chest', 'Broken Glass', 'Shovel', 'Bomb']}
        self.extra_turn = False
        self.skips_turn = False
    
    def place_item(self, difficulty):
        
        assigned_coords = set()
        for item in self.items.keys():
            if difficulty == "easy":
                prompt_row = "Enter a letter A-E: "
                prompt_col = "Enter a number 1-5: "
            elif difficulty == "hard":
                prompt_row = "Enter a letter A-J: "
                prompt_col = "Enter a number 1-10: "
            else:
                raise ValueError("Invalid difficulty. Choose 'easy' or 'hard'.")

            while True:
                row = input(f"What ROW do you want to place the {item}? {prompt_row}").upper()
                col = input(f"What COLUMN do you want to place the {item}? {prompt_col}")

                coordinates = (row, col)
                if coordinates not in assigned_coords:
                    assigned_coords.add(coordinates)
                    break
                else:
                    print("Error: Coordinates already chosen for another item. "
                          "Please pick a different set of coordinates.")

            self.items[item] = coordinates

        return self.items
    
    def guess_location(self, grid_size, board):
        """
        Takes input from the player to guess the location of the treasure chest.
 
        Parameters:
        - grid_size (int): The size of the game grid.
        - board (Board): The game board.

        Returns:
        tuple: The player's guess in the format (row, column).
        """

        
        while True:
            row = input(f"{self.name}, what ROW do you think the treasure chest 
                is at? Enter a letter A-{chr(65 + grid_size - 1)}: ").upper()

            if 'A' <= row <= chr(65 + grid_size - 1) and len(row) == 1:
                col = input(f"What COLUMN do you think the treasure chest is at?
                            Enter a number 1-{grid_size}: ")

                if col.isdigit() and 1 <= int(col) <= grid_size:
                    col = int(col)
                    guess = (row, col)
                    if guess not in board.guesses:
                        return guess
                    else:
                        print("You already guessed this location. Try again.")
                else:
                    print(f"Invalid input. Please enter a valid integer for the 
                          column (1-{grid_size}).")
            else:
                print(f"Invalid input. Please enter a valid row 
                      (A-{chr(65 + grid_size - 1)}).")

 

class ComputerPlayer(Player):
    """
    Represents a computer player in the Treasure Hunt game.
    
    Attributes: 
        - name (str): the name of the player.
        - grid_size (int): the size of the game grid.
        - board (Board): the game board.
        """
    def __init__(self, name, grid):
      super().__init__(name)
      self.grid = grid
      
class Board:
    """
    Represents the game board in the Treasure Hunt game.
    
    Attributes:
    - grid_size(int): the size of the game grid.
    - guess (tuple): the guess in the format (row, column)."""
    
    def __init__(self, grid_size):
        """
        Initializes a new Board instance.
        
        Args:
        - grid_size (int): THe size of the game grid.
        
        Side effects:
        - initializes grid_size.
        - initializes guesses.
        """
        self.grid_size = grid_size
        self.guesses = set()
        
class TreasureHuntGame:
    """Allows user to play TreasureHuntGame based on their own input and either
    the input of either a second user or the computer
    
    Attributes:
    - event_type(str): string representing found item
    - player(str): string representing the player"""
    


    #play function
    def play(self):
            """Play the game.
            
            Side effects:
                Writes to stdout.
                See also turn().
            """

            while self.outcome() is None:
                turn += 1
                player = self.players[turn % len(self.players)]
                if self.score[player.name] < self.objects:
                    continue
                self.turn(player)
            print(self.state().board)
            outcome = self.outcome()
            if outcome == "win":
                print(f"{player.name} wins!")
            else:
                print(f"The {object} was buried at {coordinates}. Play again 
                    for another chance to find treasure!")
                

    #Remy's Methods

    def outcome(Player):
        """Determines if there is a winner or loser

        Args:
            Player (Player): A player object that will play the game

        Returns:
            str: outcome of the game (i.e. player one wins/loses or None if the 
            the game is not over)
            
        Primary Author: Remington Nelson
        """
        
        if Player.objects.contains("Treasure"):
            return "win"
        elif Player.objects.contains("Bomb"):
            return "lose"
        else:
            return None
        

    def __str__(self, player_index):
        """Prints display board as formal string representation, determining how 
        to represent glass '[G]' and user choices '[X]'
        
        Args: player_index(str): index of the current player in the list of players
        """
        result = ""
        result += "    " + "   ".join(str(i) for i in range(1, self.grid_size + 1)) + "\n"
        for row in range(ord('A'), ord('A') + self.grid_size):
            result += chr(row) + "  "
            for col in range(1, self.grid_size + 1):
                current_position = (chr(row), col)

                if current_position in self.boards[player_index].guesses:
                    for item, coords in self.players[1 - player_index].items.items():
                        if current_position == coords:
                            if "glass" in item.lower():
                                result += "[G] "
                            else:
                                result += f"[{item[0]}] "
                            break
                    else:
                        result += "[X] "
                else:
                    result += "[ ] "
            result += "\n"
        return result
    


    def place_item_comp(self,difficulty):
        assigned_coordinates = set()
        for item in self.items.keys():
            while True:
                if difficulty == "easy":
                    #list of items to place on board
                    letter_choice = 'ABCDE'
                    # make a random choice for the column
                    row = random.choice(letter_choice)
                    #make a random choice for the row 
                    column = random.randint(1,5)
                elif difficulty == "hard":
                    letter_hard = 'ABCDEFGHIJ'
                    row = random.choice(letter_hard)
                    column = random.randint(1,10)
                else:
                    raise ValueError("Invalid difficulty. Choose 'easy' or 'hard'.")
                
                coordinates = (row, column)
                
                if coordinates not in assigned_coordinates:
                    break
                
            assigned_coordinates.add(coordinates)
            self.items[item] = coordinates
        
        return self.items
    
def parse_args(arglist):
    """ Parse command-line arguments
    
    Expect mandatory arguments:
        - p1: name of player 1
        
    Allow optional second player is applicable:
        - p2, --player2: if specified, include a second player 
    """
    parser = ArgumentParser()
    parser.add_argument("p1", help="name of player 1")
    parser.add_argument("p2", "--player2", help="add a second player")
    
    return parser.parse_args(arglist)

if __name__ == "__main__":
    args = parse_args(sys.argv[1:])
    main(args.p1, args.player2)




#Deandre's methods

import random

class Board:
    def __init__(self, difficulty="easy"):
        """
        Initialize the game board with the specified difficulty.

        Args:
        difficulty (str): Either "easy" (default) or "hard" to determine the grid size.
        """
        self.difficulty = difficulty
        self.grid_size = 8 if difficulty == "easy" else 10
        self.grid = [[' ' for _ in range(self.grid_size)] for _ in range(self.grid_size)]
        self.items = [(random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1)) for _ in range(self.grid_size)]

    
    def item_reveal(self, player, other, otherPlayerBoard):
        """ Reveals location of remaining items 
        
        Args:
            player(Player): name of player that won/lost
            other(Player): name of other player
            otherPlayerBoard(Board): other player's board guesses
        
        Side effects:
            prints the location of the items for each player's board
        """
            
        player_missed_items = set(other.items.values()) - self.guesses

        other_missed_items = set(player.items.values()) - otherPlayerBoard.guesses

        print(f'''Here are the locations of the items {player.name} has missed on {other.name}'s board: {player_missed_items}''')
        print(f'''and locations of items {other.name} has missed on {player.name}'s board: {other_missed_items}''')
    
    
    def grid_state(self, guess):
        """
        Update the game board based on the player's guess.

        Args:
        guess (tuple): A tuple containing the player's guess as (row, column).

        Returns:
        str: A string representing the game board's current state.
        """
        row, col = guess

        if guess in self.items:
            self.items.remove(guess)
            self.grid[row][col] = 'X'  # Mark the item as found
        else:
            self.grid[row][col] = 'O'  # Mark the guess as a miss
            
    def handle_event_type(self, event_type, player):
        """
        Handles the case where a bomb, shovel, or broken glass is found by the player, 
        resulting in the player losing the game (bomb), getting an extra turn (shovel),
        or losing a turn (broken glass).
        
        Args: 
        - event_type(str): string representing found item
        - player(str): string representing the player
        
        Side effects: changes value of player.extra_turn and player.skips_turn 
        based on event type
        """
        if event_type == 'bomb_found':
            print(f"Sorry {player.name}, you found the bomb placed your opponent. You lose!") 
        
        elif event_type == 'shovel_found':
            print(f"{player.name}, you found a shovel! You get an extra turn to dig again!")
            player.extra_turn = True
            
        elif event_type == 'broken glass_found':
            print(f'''Ouch! {player.name}, you found broken glass and injured yourself.
            Skip a turn while you bandage yourself up!''')
            player.skips_turn = True 

    def __str__(self):
        """
        Provide a string representation of the game board's current state.

        Returns:
        str: A string representing the game board.
        """
        game_state = ""
        for i in range(self.grid_size):
            for j in range(self.grid_size):
                if (i, j) in self.items:
                    game_state += ' '
                else:
                    game_state += self.grid[i][j]
                game_state += ' '
            game_state += '\n'

        return game_state


def main(player1, player2=None):
    """Creating instances of players to classes and set up and play game
    
    Args: 
        player1(str): name of player 1
        player2(str): name of player 2, default to None
    
    Side effects: 
        Prints intro to Treasure Hunt Island
        Changes player1 and player2 value based on user input
    
    """
    
    print('''\n
    Welcome to Treasure Hunt Island! \n
    The objective of this game is to outwit your opponent and find their hidden treasure chest. \n
    But be cautious! The island is full of surprises ... \n
        * Shovel --- Dig it up for an extra turn. \n
        * Broken Glass --- Beware, it skips your next turn. \n
        * Bomb --- Uncover this and BOOM, it's game over. \n
    Find the treasure chest before your opponent does to win the game! Good luck!\n''')

    if player2 == None:
        print(f"Hello {player1}! You will be playing against our computer player, Hunter.")
        player1 = Player(player1)
        player2 = Computer("Hunter")

    else:
        print(f"Hello {player1} and {player2}! ")
        player1 = Player(player1)
        player2 = Player(player2)
        
    players = [player1, player2]


    game = Game(players)
    game.set_up_game()
    game.play_game()
