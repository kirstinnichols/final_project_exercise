from argparse import ArgumentParser 
import sys 
import random



class Player:
    """Creates an abstract class called Player for a player
    
    Attributes: 
    name(str): the player's name
    """
    def __init__(self, name):
        self.name = name
        self.items = {"treasure chest": None, "broken bottle": None, "shovel": None, "bomb": None}

    def turn(self, state):
            """Take a turn.
         Args:
              state(GameState): a snapshot of the current state of the game.
            
         Returns:
              str: the coordinates that the player guessed
             """
             
            raise NotImplementedError("Subclasses implement the 'turn' method")

class HumanPlayer(Player):
    """Class for human player
    
    Attributes:
    name(str): the player's name"""
    def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the player's guess (a letter or a word)
            """
        
        print(f"{self.name}, guess a set of coordinates of a hidden object: {state}")
        return input()
    
    def place_item(self, difficulty):
        
        assigned_coords = set()
        for item in self.items.keys():
            if difficulty == "easy":
                prompt_row = "Enter a letter A-E: "
                prompt_col = "Enter a number 1-5: "
            elif difficulty == "hard":
                prompt_row = "Enter a letter A-J: "
                prompt_col = "Enter a number 1-10: "
            else:
                raise ValueError("Invalid difficulty. Choose 'easy' or 'hard'.")

            while True:
                row = input(f"What ROW do you want to place the {item}? {prompt_row}").upper()
                col = input(f"What COLUMN do you want to place the {item}? {prompt_col}")

                coordinates = (row, col)
                if coordinates not in assigned_coords:
                    assigned_coords.add(coordinates)
                    break
                else:
                    print("Error: Coordinates already chosen for another item. "
                          "Please pick a different set of coordinates.")

            self.items[item] = coordinates

        return self.items
 

class ComputerPlayer(Player):
    """ Class for a computer player
    
    Attributes: 
        name(str): the player's name
        vocab(list of strings): words that the computer can draw from when taking turns
        """
    def __init__(self, name, grid):
      super().__init__(name)
      self.grid = grid



#play function
def play(self):
        """Play the game.
        
        Side effects:
            Writes to stdout.
            See also turn().
        """

        while self.outcome() is None:
            turn += 1
            player = self.players[turn % len(self.players)]
            if self.score[player.name] < self.objects:
                continue
            self.turn(player)
        print(self.state().board)
        outcome = self.outcome()
        if outcome == "win":
            print(f"{player.name} wins!")
        else:
            print(f"The {object} was buried at {coordinates}. Play again 
                  for another chance to find treasure!")
            

#Remy's Methods

def outcome(Player):
    """Determines if there is a winner or loser

    Args:
        Player (Player): A player object that will play the game

    Returns:
        str: outcome of the game (i.e. player one wins/loses or None if the 
        the game is not over)
    """
    
    if Player.objects.contains("Treasure"):
        return "win"
    elif Player.objects.contains("Bomb"):
        return "lose"
    else:
        return None
    
#Aileen's methods for set operations and comprehension **changed technique** 
def guess(players_guess):
    guessed_coords = set()
    unguessed_coords = set()
    coordinates = {"A1", "B1" "C1", "D1", "E1",
                "A2", "B2", "C2", "D2", "E2",
                "A3", "B3", "C3", "D3", "E3",
                "A4", "B4", "C4", "D4", "E4",
                "A5", "B5", "C5", "D5", "E5"}
    guessed_coords.add(players_guess)
    unguessed_coords = {coordinates - guessed_coords}
    print(guessed_coords)
    print(unguessed_coords)

def wrong_guesses(guessed_coords, item_locations):
    wrong_coords = {coord for coord in guessed_coords if coord not in 
                        item_locations}
    print(wrong_coords)

    
    
def main(HumanPlayer, GameBoard, ComputerPlayer=None):
    print("Welcome to Treasure Hunt!")
    name1 = input("To get started, please enter your name: ")
    human1=HumanPlayer(name1)
    players = input("How many players are playing today?(1 or 2) ")
    
    while players > 2 or players < 1:
        players = input("Please ONLY enter 1 or 2 players: ")
        
    if players == 1:
        ComputerPlayer = ComputerPlayer("Rob-ot")
    elif players == 2:
        name2 = input("Please enter the second player's name: ")
        human2 = HumanPlayer(name2)
            

    difficulty = input("Would you like to play on easy or hard mode? ")
    while not(difficulty == "easy" or difficulty == "hard"):
        difficulty = input("Please ONLY enter 'easy' or 'hard': ")
   
    game=GameBoard(difficulty)
    
    
    if ComputerPlayer == None:
        human2=HumanPlayer
        while outcome(human1) is None and outcome(human2) is None:
            play(human1)
            play(human2)
            print(game)
    elif ComputerPlayer is not None:
        while outcome(ComputerPlayer) is None and outcome(human1) is None:
                play(human1)
                play(ComputerPlayer)
                print(game)


#Adom's methods
def item_hit(self,item):
    "You hit a shovel, you get one more turn" if item == "shovel" else "You hit\
    a broken bottle, skip your turn" if item == "broken bottle" else "You\
    hit a bomb, you lose" if item == "bomb" else "You found the treasure chest,\
    you win!" if item == "treasure chest" else "You didn't find anything"         


def place_item_comp(self,difficulty):
    assigned_coordinates = set()
    for item in self.items.keys():
        while True:
            if difficulty == "easy":
                #list of items to place on board
                letter_choice = 'ABCDE'
                # make a random choice for the column
                row = random.choice(letter_choice)
                #make a random choice for the row 
                column = random.randint(1,5)
            elif difficulty == "hard":
                letter_hard = 'ABCDEFGHIJ'
                row = random.choice(letter_hard)
                column = random.randint(1,10)
            else:
                raise ValueError("Invalid difficulty. Choose 'easy' or 'hard'.")
            
            coordinates = (row, column)
            
            if coordinates not in assigned_coordinates:
                break
            
        assigned_coordinates.add(coordinates)
        self.items[item] = coordinates
    
    return self.items
    
def parse_args(arglist):
    """ Parse command-line arguments
    
    Expect mandatory arguments:
        - p1: name of player 1
        
    Allow optional second player is applicable:
        - p2, --player2: if specified, include a second player 
    """
    parser = ArgumentParser()
    parser.add_argument("p1", help="name of player 1")
    parser.add_argument("p2", "--player2", help="add a second player")
    
    return parser.parse_args(arglist)

if __name__ == "__main__":
    args = parse_args(sys.argv[1:])
    main(args.p1, args.player2)




#Deandre's methods

import random

class GameBoard:
    def __init__(self, difficulty="easy"):
        """
        Initialize the game board with the specified difficulty.

        Args:
        difficulty (str): Either "easy" (default) or "hard" to determine the grid size.
        """
        self.difficulty = difficulty
        self.grid_size = 8 if difficulty == "easy" else 10
        self.grid = [[' ' for _ in range(self.grid_size)] for _ in range(self.grid_size)]
        self.items = [(random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1)) for _ in range(self.grid_size)]

    def grid_state(self, guess):
        """
        Update the game board based on the player's guess.

        Args:
        guess (tuple): A tuple containing the player's guess as (row, column).

        Returns:
        str: A string representing the game board's current state.
        """
        row, col = guess

        if guess in self.items:
            self.items.remove(guess)
            self.grid[row][col] = 'X'  # Mark the item as found
        else:
            self.grid[row][col] = 'O'  # Mark the guess as a miss

    def __str__(self):
        """
        Provide a string representation of the game board's current state.

        Returns:
        str: A string representing the game board.
        """
        game_state = ""
        for i in range(self.grid_size):
            for j in range(self.grid_size):
                if (i, j) in self.items:
                    game_state += ' '
                else:
                    game_state += self.grid[i][j]
                game_state += ' '
            game_state += '\n'

        return game_state


difficulty = "hard"  
game = GameBoard(difficulty)

print(game)  
game.grid_state((1, 2))  
print(game)  

