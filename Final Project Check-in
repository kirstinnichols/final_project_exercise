
#Kirstin's methods


class Player:
    """Creates an abstract class called Player for a player
    
    Attributes: 
    name(str): the player's name
    """
def __init__(self, name):
    self.name = name

def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the coordinates that the player guessed
            """
        raise NotImplementedError("Subclasses implement the 'turn' method")

class HumanPlayer(Player):
    """Class for human player
    
    Attributes:
    name(str): the player's name"""
    def turn(self, state):
        """Take a turn.
        Args:
            state(GameState): a snapshot of the current state of the game.
            
        Returns:
            str: the player's guess (a letter or a word)
            """
        
        print(f"{self.name}, guess a set of coordinates of a hidden object: {state}")
        return input()

class ComputerPlayer(Player):
    """ Class for a computer player
    
    Attributes: 
        name(str): the player's name
        vocab(list of strings): words that the computer can draw from when taking turns
        """
    def __init__(self, name, grid):
      super().__init__(name)
      self.grid = grid



#play function
def play(self):
        """Play the game.
        
        Side effects:
            Writes to stdout.
            See also turn().
        """

        while self.outcome() is None:
            turn += 1
            player = self.players[turn % len(self.players)]
            if self.score[player.name] < self.objects:
                continue
            self.turn(player)
        print(self.state().board)
        outcome = self.outcome()
        if outcome == "win":
            print(f"{player.name} wins!")
        else:
            print(f"The {object} was buried at {coordinates}. Play again 
                  for another chance to find treasure!")
            
            
#Remy's Methods

def outcome(Player):
    """Determines if there is a winner or loser

    Args:
        Player (Player): A player object that will play the game

    Returns:
        str: outcome of the game (i.e. player one wins/loses or None if the 
        the game is not over)
    """
    
    if Player.objects.contains("Treasure"):
        return "win"
    elif Player.objects.contains("Bomb"):
        return "lose"
    else:
        return None
    
    
    
def main(HumanPlayer, GameBoard, ComputerPlayer=None):
    print("Welcome to Treasure Hunt!")
    name1 = input("To get started, please enter your name: ")
    human1=HumanPlayer(name1)
    players = input("How many players are playing today?(1 or 2) ")
    
    while players > 2 or players < 1:
        players = input("Please ONLY enter 1 or 2 players: ")
        
    if players == 1:
        ComputerPlayer = ComputerPlayer("Rob-ot")
    elif players == 2:
        name2 = input("Please enter the second player's name: ")
        human2 = HumanPlayer(name2)
            

    difficulty = input("Would you like to play on easy or hard mode? ")
    while not(difficulty == "easy" or difficulty == "hard"):
        difficulty = input("Please ONLY enter 'easy' or 'hard': ")
   
    game=GameBoard(difficulty)
    
    
    if ComputerPlayer == None:
        human2=HumanPlayer
        while outcome(human1) is None and outcome(human2) is None:
            play(human1)
            play(human2)
            print(game)
    elif ComputerPlayer is not None:
        while outcome(ComputerPlayer) is None and outcome(human1) is None:
                play(human1)
                play(ComputerPlayer)
                print(game)
        